# [Site Reliability Engineering](https://www.oreilly.co.jp/books/9784873117911/)

## 第１部：イントロダクション

### １章：イントロダクション

- Googleでは全てのSREに対して、チケット、おんコール、手作業といった運用業務の合計を一定以下にするよう、上限を設けた。
- SREの責任：サービスの可用性、レイテンシ、パフォーマンス、効率性、変更管理、モニタリング、緊急対応、キャパシティプランニング
- サービス障害は予測可能でコントロールするべきもの。SREとプロダクト開発者は、機能のリリース速度を最大化するためにエラーバジェットを使うことを目標にする

### ２章：SREの観点から見たGoogleのプロダクション環境

- N+2の冗長性：アップデートによってタスクが一つずつ使えなくなる＋アップデート中にマシン一台に障害が発生する

## 第２部：原則

### ３章：リスクの需要

- サイトリライアビリティエンジニアリングでは、単純に稼働時間を最大化するよりも、可用性におけるリスクと、イノベーションの速度およびサービス運用の効率性というゴールのバランスを取ろうとする。これによってユーザーの満足感を機能、サービス、パフォーマンスについて最適化する
- サービスのリスク許容度の評価要素：必要な可用性のレベル、障害の種類によるサービスへの影響の違い、リスク曲線上におけるサービスコストの変化、検討できるサービスメトリクスの種類
- 可用性のターゲットレベルの要素：ユーザーの期待、サービスが直接的に収入につながっているか、サービスが有料か無料か、競合のサービスレベル、コンシューマ向けか企業向けか
- エラーバジェット：一つの期間内でサービスの信頼性がどの程度損なわれても許容できるかを示す、明確で客観的なメトリクス。エラーバジェットが消費されてきたら、リリースを一時的に停止させ、システムの弾力性強化などを実施するきっかけにできる。

### ４章：サービスレベル目標

- SLAはユーザーとの間で結ぶ契約であり、ビジネスやプロダクトに関する判断に密接に関わる。SREはSLAの構築には関わらないことが多いが、SLOの遵守やSLIの定義の支援には関わる。
- ユーザーとやり取りするサーバー、ストレージ、ビッグデータシステムなど、サービスの内容によってSLIの傾向は変わる
- ほとんどのメトリクスは、平均よりも分布として見る方が状態への適切な理解が得られる。
- SLOを常に満たし続けることを求めるのは現実的ではない。それよりもエラーバジェットを認めて日毎や週ごとに追跡した方が良い。エラーバジェットは他のSLOを満たすためのSLOに過ぎない。
- SLOを考えるときは、まずユーザーが気にすることは何かを考える。
- SLOを設定するためのポイント
  - 現在のパフォーマンスに基づいてターゲットを選択してはならない
  - シンプルさを保つ
  - 「絶対」は避ける
  - SLOは最小限に留める
  - 最初から完璧でなくても良い

### ５章：トイルの撲滅

- トイルの傾向：手作業、繰り返される、自動化できる、（戦略的でなく）戦術的、長期的な価値を持たない、サービスの成長に対して線形
- トイルを減らし、サービスをスケールさせる作業が、SREにおける「エンジニアリング」である
- 典型的なSREの活動は以下。GoogleのSREは一定期間で平均した時、最低50パーセントをエンジニアリングの作業に充てると目標にしている。
  - ソフトウェアエンジニアリング
  - システムエンジニアリング
  - トイル
  - オーバーヘッド

### ６章：分散システムのモニタリング

- 人間へのアラートを発生させるルールは、理解しやすく、明確な障害を表現するものであるべき
- モニタリングシステムは、何が壊れたのか、なぜそれが壊れたのかという二つに答える必要がある
- ホワイトボックスモニタリングは、ログやHTTPエンドポイントなどの、システム内部を調査する機能に依存しており、リトライなどによってマスクされる障害や、近々生じそうな問題を検出できる。ブラックボックスモニタリングは、現在システムが正常に動作していない、というような症状を扱う。
- ユーザーが直接利用するシステムにおける代表的なシグナル：レイテンシ、トラフィック、エラー、サチュレーション。
- 計測の粒度を細かくしすぎると、収集、保存、分析のコストが大きくなるので注意が必要
- モニタリングの対象を選別する上でのガイドラインは以下
  - 本当のインシデントを最も頻繁に捉えるルールは、可能な限りシンプルであり、予想しやすく信頼できるものであるべき
  - ほとんど実施されない（例えばSREチームによっては、四半期に１回未満が目安）データの収集、集計、アラートの設定は削除すべき
  - 収集されていても、事前に作成されたダッシュボードのいずれにも表示されず、どのアラートにも使われていないシグナルは削除の対象
- モニタリングやアラートのルールを作成する際のガイドラインは以下
  - ルールが検出する状況は、そのルールなしでは検出されない状況であり、緊急で、対応が可能で、ユーザーに影響を及ぼすか？
  - そのアラートが無害なものだと判断して、対応せずにそのままにしてしまえるか？
  - そのアラートは間違いなく、ユーザーに悪影響が生じていることを示しているか？
  - そのアラートに対応してアクションを取れるか？アクションは自動化できないか？
  - その問題でページを受ける人は他にもいるか？

### ７章：Googleにおける自動化の進化

- 大規模なサービスほど、自動化による一貫性、素早さ、信頼性というメリットが大きくなる
- 特定のオペレーションを自動化するだけでなく、そのオペレーションがシステムによって自律的に解決されるようなソフトウェア開発も視野に入れる必要がある。
- 自律的な運用を大規模システムに対応させるのは難しいが、その過程におけるサブシステムの分離やAPIの導入、副作用の最小化などの優れたエンジニアリングプラクティスは非常に役に立つ
- 感想：Googleにおける自動化・自律化の振り返り。やや抽象的に感じた。

### ８章：リリースエンジニアリング

- リリースエンジニアリングにおける４つの哲学：セルフサービスモデル、高速性、密封ビルド、ポリシーと手順の強制
- 適切なツールや自動化、しっかり定義されたポリシーがあれば、開発者やSREはソフトウェアのリリースについて心配せずに済む。
- リリースエンジニアリングは初期の段階から始めた方が良い

### ９章：単純さ

- システム管理におけるSREのアプローチをまとめると、「システム内でのアジリティと安定性のバランスを取ること」と言える
- ソフトウェアに単純性を導入することは、開発における信頼性を増すことにつながり、開発者は作成するソフトウェアやシステムの機能やパフォーマンスという、自分達が本当に注目しなければならないことに集中できるようになる
- SREチームが実施すべきこと
  - 受け持っているシステムに想定外の複雑さが生じていたら差し戻す
  - 関わっているシステムや、運用を受け持つことになるシステムから複雑さを取り除く努力
- 不要なコードをコメントアウトやフラグ管理で対応しようとするのは悪い提案である
- プロジェクトにおいて変更や追加されたコードの1行1行は、潜在的に障害やバグの可能性もつ
- 利用者に提供するメソッドや引数が少ないほど、APIは理解しやすくなり、それらのメソッドを改善するための努力も容易になる

## 第３部：実践

- SREが行うのは、サービスを稼働させ、その健全性の責任を持つこと。そのためにはモニタリングシステムの開発やキャパシティプランニング、インシデント対応、サービス障害の根本原因解決の確認などがある。
- サービスの健全性は、システムがサービスとして機能するための基本的な必要条件から、サービスの方向性を能動的にコントロールするような高度な機能まで広いレベルがある。

### 10章：時系列データからの実践的なアラート

  * 必要なのは、高レベルのサービスの目的に関するアラートを発しながら、必要に応じて個々のコンポーネントの調査もできる粒度の情報を保つようなモニタリング
  * Borgを補完するモニタリングシステムとしてBorgmonが生まれた。Borgmonは共通のデータ公開フォーマットを利用することで、オーバーヘッドを抑えながら大量のデータを収集できる。OSSとしてはRiemannやPrometheusなどがある。
  * ホワイトボックスモニタリングだけでは、ユーザーの視点に気づけなくなるため、ブラックボックスモニタリングも合わせて必要
  * Borgmonは設定したルールに対するユニットテスト、回帰テストの構築方法も提供している

### 11章：オンコール対応

  * どんなインシデントも、一つの根本原因から生じる一連のイベントとアラートと位置づけ、同じポストモーテムの一部として議論するべき。
  * インシデント対応は拙速な対応よりも慎重な判断が必要。そのためには以下が特に重要
	* 明確なエスカレーションパス
	* しっかりと規定されたインシデント管理の手順
	* 避難を伴わないポストモーテム文化
  * Google内部では、Webベースのツールによって、インシデント発生時の役割の受け渡しや状況の更新の記録、通知などをサポートしている
  * 運用の負荷が大きすぎると判断される場合には、開発チームと交渉してシステム改善の目標を設定し協力するのも良い

### 12章：効果的なトラブルシューティング

  * システムの問題に対して効果的なレポートを作るには、期待される動作と実際の動作、可能なら再現手順を含める。
  * 大きなサービス障害に際してまず必要となるのは、根本原因の究明ではなくシステムをできる限りうまく動作するように手当てすることとなる。
  * 異常を起こしているシステムに対しては、「何が」「どこで」「なぜ」異常を起こしているのか考える
  * テストと対応：明らかなことから考え始める、テストが環境に与える影響を考える、再現が難しい問題は妥協が必要な時もある、など
  * 否定的な結果も有益となる。実験結果は決定的なものであり、ツールや方法論は実験結果よりもさらに長く残る。また結果を公開することで、組織のナレッジにもなる。
  * 問題を起こした要因を見つけたら、システムで生じた問題、問題を突き止めた過程、問題の解決方法、再発防止策を書いておく→ポストモーテムの作成
  * 特定しきれていないバグを残したままのローンチは理想的ではないが、既知のバグを無くし切るのが現実的でない場合には、エンジニアリング上の判断を下して次善の対応を行う場合もある。
  * トラブルシューティングを迅速に行うための基本的なアプローチ
	* 観察のための仕組みを構築する。ホワイトボックスのメトリクスと、構造化されたログの双方を、基盤の部分から上位に至るまでの各コンポーネントに組み込む
	* システムの設計時に、十分に知られている技術を使ってコンポーネント間に観察可能なインターフェースを持たせる

### 13章：緊急対応

### 14章：インシデント対応

### 15章：ポストモーテムの文化、失敗からの学び

### 16章：サービス障害の追跡

### 17章：信頼性のためのテスト

### 18章：SREにおけるソフトウェアエンジニアリング

### 19章：フロントエンドにおけるロードバランシング

### 20章：データセンターでのロードバランシング

### 21章：過負荷への対応

### 22章：カスケード障害への対応

### 23章：クリティカルな状態の管理

### 24章：cronによる分散定期スケジューリング

### 25章：データ処理のパイプライン

### 26章：データの完全性：What You Read Is What You Wrote

### 27章：大規模なプロダクトのローンチにおける信頼性

## 第４部：管理

### 28章：SREの成長を加速する方法：新人からオンコール担当、そしてその先へ


