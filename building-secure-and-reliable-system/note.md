# [Building Secure and Reliable System](https://www.oreilly.co.jp/books/9784814400256/)

## 第１部：入門資料

### １章：セキュリティと信頼性が交わるところ

- 信頼性にとっての主要なリスク：ソフトウェアの不適切な更新やデバイスの物理的な故障など、悪意がないもの
- セキュリティにとっての主要なリスク：システムの脆弱性を積極的に悪用しようとする攻撃者によってもたらされる
- セキュリティと信頼性は、どちらもシステムの機密性、完全性、可用性に関係している。二つの視点の大きな違いは、悪意のある攻撃者を想定するか否か
- 信頼性とセキュリティの共通点：効力の不可視性、評価方法、単純さの有用性、システムの進化への対応、弾力性、システムの調査とロギング、危機対応など
- インシデントによって企業のバリュエーションを毀損してしまうのは想像しやすい（Yahoo の事例）
- セキュリティと信頼性には多くの共通点があり、どちらも当初は速度の名の下に犠牲にしたくなるが、何かあってから修正するのはコストがかかる

### ２章：攻撃者に対する理解

- 攻撃者のモチベーション：好奇心、名声、金銭的利益、強制、諜報など
- 攻撃者のプロファイル：ホビイスト、脆弱性研究者、政府及び法執行機関、活動家、犯罪当事者、インサイダーなど
  - 政府機関の中には、軍事目的や国内活動の取り締まりなどさまざまなモチベーションがある
- ハードウェアの詳細や暗号など秘匿性の高い情報を扱うサービスは、攻撃者のターゲットとなり得る
- CAPTCHA システムなどを用いることで、攻撃のコストをあげ、攻撃者からの優先度を下げることができる
- 信頼性と安全性を兼ね備えたシステム設計の際には、ミスを犯すかもしれないインサイダーと、従業員のアカウントを乗っ取るかもしれない攻撃者の両方を考慮するのが良い
- インサイダーリスクは、当事者、動機、行動、標的などに応じたモデル化ができる
- インサイダーリスクの分析に効果的な観点：最小権限、ゼロトラスト、マルチパーティ認可、ビジネス上の正当性、監査と検出、リカバリ可能性
- 攻撃者の手法を学ぶための３つのインテリジェンス：脅威インテリジェンス、サイバーキルチェーン、戦術・技術・手順（TTPs）
  - [ARR&CK フレームワーク](https://attack.mitre.org/)はサイバーキルチェーンの各段階を詳細に説明している

## 第２部：システムの設計

### ３章：ケーススタディ：セーフプロキシ

- セーフプロキシは、許可を受けたものが物理サーバーや特定のアプリケーションにアクセスしたり、変更したりすることを可能にする
- セーフプロキシは Google の [Zero Touch Prod](https://www.usenix.org/conference/srecon19emea/presentation/czapinski) プロジェクトを実現するためのツールの一つ
- クライアントが人間か自動ツールかに関わらず、プロキシを利用することでメリットがある
  - マルチパーティ認可（MPA）
  - 管理者による使用状況の監視
  - レート制御
  - サードパーティによるクローズドソースのターゲットシステムとの互換性
  - 継続的な改善の統合
- 一方で、プロキシには欠点や潜在的な落とし穴もある：メンテナンスや運用のオーバーヘッド、構成によっては単一障害点となり得る、アクセス制御のためのポリシー設定自体がエラーの温床となり得る、など
- プロキシ経由によってリモートアクセスの履歴が残るだけでも、管理上有用そう

### ４章：設計におけるトレードオフ

- プロダクトの機能要件は、セキュリティや信頼性の要件とは大きく異なる特性を示す傾向がある
- 機能要件は、要件と対応するコード、それを検証するためのテストなどと具体的に結びつきやすいが、信頼性やセキュリティなどの非機能要件は直接的に実装やテストするのは難しい場合が多い
- 信頼性やセキュリティは、システムの設計や開発・運用に基づく創発特性と言える
  - 信頼性を創発する要因：マイクロサービスの構成、コンポーネント間の通信の仕組み、オブザーバビリティの仕組み
  - セキュリティを創発する要因：システムコンポーネント間の信頼関係、利用される言語・フレームワーク、セキュリティレビューや監査の仕組み
- Google の設計ドキュメントテンプレート：スケーラビリティ、冗長性と信頼性、依存関係への考慮、データ完全性、セキュリティとプライバシーに関する考慮など
- 出来上がったシステムに後からセキュリティや信頼性の要件を足そうとすると、大幅な設計変更や追加の欠陥が含まれる可能性もある。こうした非機能要件は、設計の初期にセキュリティや SRE チームが関与しつつ、そのコストやリスクについてよく考える必要がある
- 信頼性やセキュリティをカバーするための Google の Web アプリケーションフレームワーク、具体的にどんな内容なのか気になる
- 信頼性やセキュリティの検討を後回しにすれば開発の初期速度は上がるが、開発を継続する上での持続速度が上がらなくなってしまう
  - 信頼性に関しては自動テストや CI/CD パイプライン、ロールアウトやロールバックを柔軟に行うためのインフラを整備することで、持続速度を高めることができる
  - セキュリティについては、関連するクラスの脆弱性に対して構造上安全な（secure-by-construction）防御（？）を提供するフレームワークとワークフローを選択するのが良
- ユーザーが利用するプロダクション環境においては信頼性やセキュリティはオプションではない。これらをカバーするための先行投資はよく検討すれば現実的な範囲で収めることもできる。

### ５章：最小権限を前提とする設計

- 最小権限を運用する上では、生産性とセキュリティ、信頼性のバランスを維持して取り組む必要がある
- 最小権限モデルを実装する際のベストプラクティス
  - 小さく機能的な API：API を分割してそれぞれを小さくすることで、特定のアクションに必要なパーミッションを適切に与えることができる
  - 監査：良質な監査ログの収集、監査担当者の選択。監査には大別して「ベストプラクティス遵守の確認のため」と「セキュリティ違反特定のため」の２種類がある
  - テストと最小権限：最小権限のテスト（リソースに付与される権限が必要十分か）と、最小権限でのテスト（テスト実施環境の権限が必要十分か）がある
	- 最小権限でのテストのためのテスト用インフラは小さく始めることができる：環境とクレデンシャルの分離、アクセスタイプの制限、データ露出の制限
  - アクセス拒否の診断：アクセス拒否の要因情報は攻撃者の利益となり得るので、ゼロトラストモデルを実装する初期段階では、トークンを使用し全てのクライアントにサポートチャネルを呼び出させるのが良い
  - グレースフルな障害と非常ボタン：非常ボタンを利用できる権限は厳格に管理する必要がある。その使用の監視も必要となる。
- API へのアクセス制御方法を決定するには、認証と認可が必要になる
- 認可ポリシーは、アプリケーションのバイナリとは独立して更新するのが良い。その際にはアプリケーションの開発者とセキュリティエンジニア・SRE が連携するのが推奨される
- マルチパーティ認可では、間違いの防止や攻撃コストの増加など多くの恩恵がある。一方で要求を拒否するのが精神的に難しい場合は、事後のセキュリティチームへエスカレーションしたり、一部を独立して監査するなどの方法が取れる。
- 最小権限のアクセスモデルは組織のセキュリティ改善に大きく貢献する一方で、実装には一定のコストがかかる。
  - セキュリティ要件として、「あるユーザーはどのサービスやデータにアクセスできるか」などの質問に常に答えられる必要がある
  - 情報の透明性、オープンネスとの兼ね合い
  - 開発者の複雑さを軽減するために、ガイドラインやレビューを設計する必要がある

### ６章：理解しやすさに配慮した設計

- システムの理解しやすさ：「関連する技術的背景を持つ人が次のどちらについても確信をもって正確に推論できる程度」
  - システムの運用上の動作
  - セキュリティと可用性を含む、システムの不変条件
- 理解しやすさのメリット：セキュリティの脆弱性や弾力性障害の低減、効果的なインシデント対応の促進、システムのセキュリティに対するアサーションの信頼性向上
- システムの不変条件：認可されたユーザーだけがデータベースにアクセスできる、機密データへのアクセスは全て監査ログが残る、などの要件（プロパティ）
  - あるプロパティが実際には不変条件ではない場合、そこにはセキュリティ上の弱点や脆弱性があると言える
- 現代のソフトウェアでは、ある程度の複雑さは回避できないことも多い。重要なのは、システムの特定のプロパティの動作を関係者が高い忠実度で推論できること
- ライブラリやフレームワークを用いることで、セキュリティや信頼性に関する共通の要件の責任を一元化できる
- 構造化されたインターフェース、一貫したオブジェクトモデル、冪等な操作は、システムの理解しやすさに直結する
- Google プロダクションシステムのアイデンティティモデル：管理者（Google の開発者）、マシン、ワークロード、カスタマー
- TCB：その障害がセキュリティポリシー違反を起こす可能性のあるコンポーネントの集合
- マイクロサービスをうまく設計することで、特定のセキュリティポリシーに関わる TCB を小さく保つことができる
- ソフトウェアの開発者とレビュアーは、セキュリティと信頼性に関するプロパティのうち、ライブラリやフレームワークが何を保証し、何を保証しないのかを理解する必要がある
- セキュリティや信頼性について望ましいプロパティを適用するための戦略
  - 狭く、一貫し、型付けされたインターフェース
  - 認証、認可、アカウンティングの一貫性があり慎重に実装された戦略
  - ソフトウェアコンポーネントか人間の管理者かを問わない、アクティブエンティティに対するアイデンティティの明確な割り当て
  - セキュリティ不変条件をカプセル化することでコンポーネントがベストプラクティスに一貫して従うことを保証するアプリケーションフレームワークのライブラリとデータ型

### ７章：状況の変化に対応する設計

- セキュリティ体制やセキュリティインフラの弾力性改善のための変更の種類
  - セキュリティインシデントに対応するための変更
  - 新たに発見された脆弱性に対応するための変更
  - プロダクトや機能の変更
  - セキュリティ体制を改善するための内発的に動機づけされた変更
  - 新しい規制要件など、外発的に動機づけられた変更
- あらゆる変更が備えるべき性質：漸進的（≒独立性）、文書化、テスト済み、分離、適格性、段階的（≒カナリア）
- 変更を容易にするアーキテクチャ上の意思決定
  - 依存関係を常に最新の状態に維持して頻繁に再構築
  - テストの自動化を活用して頻繁にリリース
  - コンテナの使用
  - マイクロサービスの使用
	- そもそもマイクロサービスを綺麗に切る必要もある
- クラウド化した世界では、マイクロサービスアーキテクチャを採用し、セキュリティ制御のレイヤー構造を構築し、サービス間の通信をサービスメッシュで管理することで、個別のチームに負担をかけることなく設定の変更ができる
- 変更を適用するのに適した速さは、重大度、依存システムやチーム、感度、機嫌などによって変化する
- ゼロデイ脆弱性への対応
  - ソフトウェアディストリビューションをできる限り標準化する
  - 公開されているディストリビューション標準を使用する
  - 緊急の変更に関して変更プッシュの仕組みを確実に実施できるように準備する
  - ロールアウトの進捗を追跡するためのモニタリング機能があり、パッチが適用されていないシステムを特定できること
  - 非標準であるか、特別な注意が必要なシステムはどれかを把握する
- 中期的にセキュリティと信頼性の文化を構築するための教訓
  - 選択するソリューションが全てのユーザーで機能することを確認する
  - 変更は習得しやすく、できるだけ負担がかからないものにする
  - 中央 IT チームの負担を最小限に抑えるために、変更をセルフサービスで提供する
  - ソリューションが機能し、ユーザーのためになることを明確な証拠で示す
  - ポリシー違反に関するフィードバックループはできるだけ迅速にする
  - 進捗状況を追跡して、ロングテールに対処する方法を判断する
- 長期の計画でリーダー層からの支援を継続的に受けるには、最新の計測とステータスでドキュメンテーションを最新の状態に保つことが重要
- 大規模かつ高速なデプロイへの備え、暗号鍵や他の秘密情報の定期的なローテーションはできるようにしたい

### ８章：弾力性を担保する設計

- 弾力性とリカバリは密接に関係している。リカバリ：壊れた後でシステムの回復する能力。弾力性：破損を遅らせるか、持ち堪える能力
- リクエストの優先順位やコスト、サーバー使用率に基づいて処理を制限（シェディング）することで、サーバーのダウンやカスケード障害の対策となる
- グレースフルデグラデーションを実装する際には、根本要因に関わらずシステムの品質低下のレベルを判断及び記録することで、診断やデバッグに役立つ
- 信頼性を最大化するためには、システムは障害に対して動作し続ける（フェイルオープン、セーフ）ことを目指す。一方でセキュリティを最大化するには、システムは動作を停止する（フェイルクローズド、セキュア）ことになる。
  - 個々のチームがまず、譲れない最小限のセキュリティ体制を決定し、次にセキュリティサービスの重要な機能が必要とする信頼性の提供方法を見つける必要がある
- 爆風半径の制御は、イベントの影響をコンパートメント化することを意味する。攻撃者や偶発障害の両方をコンパートメント化によって封じることで、弾力性を向上できる
- 鍵やクレデンシャルのローテーションによって、攻撃者の能力を時間の経過に応じて制限することができる
- 全ての障害の防止を目的とするのではなく、以下のアプローチを組み合わせることで組織にふさわしいバランスを考えることができる
  - システムを独立した障害ドメインに分割する
  - 単一の根本原因が複数の障害ドメインの要素に影響を及ぼす可能性の低減を目指す
  - 障害発生時に代わりとなりうる冗長なリソース、コンポーネント、手順を作成する
- 障害ドメイン：あるシステムの、同等ながら独立した複数のコピー。どれかに障害が起きても他のコピーは影響を受けない（K8s の Pod とか？）
- サービスの信頼性には、大容量、高可用性、低依存性という３つのクラスののコンポーネントを利用することができる
- システムの信頼性やセキュリティは、現実的かつ制御された方法で定期的に検証する必要がある。検証内容の検討には、バグやインシデントレポート、ファジング、障害注入のアプローチなどが役に立つ
- 弾力性の高いシステムを構築するためには、コストの低い順に以下が考えられる
  - 障害ドメインと爆風半径（＝影響範囲）の制御
  - 高可用性サービスの利用
  - ロードシェディングやスロットリング機能の導入（組織の規模やリスク評価から、弾力性への積極的な投資が正当化される場合）
  - DoS 攻撃に対する防御の有効性評価
  - 低依存性ソリューションの構築と、時間が経っても低依存性が維持されているかの評価プロセスや仕組み
- 弾力性確保に向けた資金や時間が得られた際には、まず最初にすでに導入した弾力性施策のコスト合理化から検討するのが良い

### ９章：リカバリを想定した設計

- リカバリのさまざまなニーズをサポートするのに必要な信頼性と柔軟性を備えたシステムを作るには、設計段階で意識して意思決定を行う必要がある
- エラーの種類：ランダムエラー（物理デバイスの故障など）、偶発的なエラー（善意の人間によるエラー）、ソフトウェアのエラー、悪意のあるアクション
- リカバリを想定して設計する際には、発生する問題の幅や多様性について先入観を持たず、そこからリカバリする準備に集中する必要がある
- 緊急時の変更プッシュシステムは単純に、通常のプッシュシステムが最大限に性能（変更適用速度など）を発揮できるように調整したものとして設計するのが良い
- インシデントの事象の緩和には、問題の原因となっている変更のロールバックが考えられる。一方で、脆弱性に対するセキュリティパッチなどの変更は安易にロールバックはできない。
  - 攻撃者がアプリケーションのバージョンを操作するケースが実際どれくらい起きうるのか？
- 拒否リスト：コンポーネントが特定のバージョンへ更新されることを防ぐためのリスト
- 最小許容セキュリティバージョン番号（MASVN）：重要なセキュリティ修正を適用し、その安定性が実証されるたびにインクリメントすることで、ロールバックの意思決定を制御するための番号
- キーやクレデンシャルの失効システムの管理によって、攻撃者の権限を速やかに失効させられるが、偶発的な動作がセキュリティや信頼性に影響を及ぼす可能性もある
- 意図したシステムの状態を徹底的にエンコードすることが、優れた自動化、セキュリティ、侵入検知、既知の状態へのリカバリを支える基盤となる
- インフラをまっさらな状態からリストアするには、複雑な依存関係を実行する可能性がある。パブリッククラウド上のサービスでは、十分なクオータがないかもしれない。
  - 想定外の事態に確実に備えるには、制御された状況下でディザスタテストを実施すると効果的なことがある
- データの削除は多くのシステムで必要な要件である。データリカバリでは、削除されたデータが誤ってリストアされないために注意が必要となる。
- 対応者が緊急アクセスのプラクティスを定期的に訓練できるようにするには、緊急アクセスをオンコール担当者の日常的な習慣に統合するポリシーを導入し、関連システムの使い勝手を継続的に検証するのが効果的となる
- ポリシー、ハウツーガイド、アーキテクチャの概要などと言ったドキュメンテーションが利用可能であることを確認すると、緊急対応のプレッシャーを緩和できる

## 第３部：システムの実装

### 12章：コードの記述

- フレームワークを用いることで、セキュリティと信頼性の責任を一元化でき、開発者の生産性を向上できる
  - SQL インジェクションに対して具体的にハードニングされたライブラリ例：TrustedSqlString
  - フレームワークは基本的に内製するよりも、広く使われており定評があるものを採用するのが良い
- RPC バックエンド用のフレームワークの場合：利用できない依存関係をグレースフルに処理し、トラフィックをリダイレクトしてサービスやその依存関係の過負荷を避けるフレームワークは、サービス自体とエコシステム両方の信頼性を改善する
- セキュリティ脆弱性の大部分は、SQL インジェクション、認証突破、機密データ漏洩、XML 外部エンティティなど10種類程度があり、それぞれにフレームワークによるハードニング対策が検討できる
- 型に基づく安全性アプローチは、SQL インジェクションや XSS の防止などに幅広く有効となる
- 考えられるユースケースを全てカバーするライブラリを構築するのは難しい。代わりに、少数の共通ユースケースだけでもカバーしており、正しく使用しやすいシンプルなライブラリから始めるのが良い。
- 脆弱性を含むコードベースのリファクタリングでは、関数の多重定義や Git フックを用いて少しずつ移行を進めることができる
- マルチレベルのネスト構造や、YAGNI コードを除去することで、シンプルで安全性の高いコードを保つことができる
- 技術的負債に取り組むためには、コード品質やカバレッジの計測、リンターの活用が考えられる。カバレッジはリファクタリングによってコードベースを整備する際にも有用となる
- チームや組織で用いるツールを慎重に選ぶことで、信頼性やセキュリティにデフォルトの保証を備えることができる
  - メモリセーフな言語や、強い型付け・静的な型チェックを備えた言語を用いると、プロジェクトのセキュリティと信頼性に貢献できる
  - メモリリークやデータ競合、デッドロックに対して、コードのサニタイザを継続的ビルドや CI に組み込むことで、メモリ管理や並行処理の典型的な落とし穴を事前に回避できる

### 13章：コードのテスト

- 重要なシステムを扱う場合には、テスト対象のコードよりもテストの作成に時間がかかるかもしれない。早期のテストはエッジケースが少なく質の高いコードベースにつながるため、長い目で見れば元がとれる
- 不安定なテストは、見つけたらすぐに修正することが大事
- テストのためのモック、スタブ、フェイクの違いよくわかってない
- 抽象化を所有するチームはサービスの進化に応じて機能セットを確実に提供できるようになり、抽象化を利用するチームは、より現実的なコンポーネントをテストで利用できるようになる
- 複雑なサービスでは、依存関係の初期化やセットアップも複雑になりやすい
- ファイルパーサー、圧縮アルゴリズム、オーディオコーデックなど、あらゆる種類のソフトウェアが処理する複雑な入力はファジングの対象として一般的と言える
  - ファジングによるテストが向いている・向いていないアプリケーションや機能はある？うまく運用するのが割と大変そう。研究レベルでは機械学習との統合は面白そう
- ファジングを利用すると、ライブラリの移行時などに同じ機能の異なる実装の整合性なども評価することもできる
- まずは他のテストまたは解析戦略がバグを防いでおくべきであり、ファジングはエンジニアが考慮していなかったかもしれないテストケースを生成することで、補完の役割を担うのが理想的
- 静的解析ツールを CI/CD に組み込むことで、開発者が問題のあるコードをプッシュする危険性を減らすことができる。Google では、プログラム解析プラットフォームのオープンソース版として [Shipshape](https://github.com/google/shipshape) (public archived) を提供している。
- テストや解析手法を CI/CD などのエンジニアリングワークフローに全面的に統合し、日常的に使用することで、より迅速にバグを発見できる

### 14章：コードのデプロイ

- ソフトウェアサプライチェーンの基本的な流れ：ソフトウェアの記述、ビルド、テスト、デプロイ
  - デプロイメント：アーティファクトを環境に割り当てること
- ソフトウェアサプライチェーンのセキュリティを継続的に改善するためのベストプラクティス
  - コードレビューの義務化
  - 自動化を頼りとする：ビルド、テスト、デプロイメントの全てのステップを自動化する。全ての設定変更にピアレビューを義務付ける。自動化システムのロックダウンの実施
  - 人間だけでなくアーティファクトも検証する：特定のステップを踏んだアーティファクトのみがデプロイできるような仕組み（GKE だと Binary Authorization など）を導入する。バイパスしてデプロイする場合でも、通知を設定するなど
  - 設定をコードとして扱う：設定の変更もアプリケーションと同様にチェックイン、レビュー、テストの考えを取り入れることができる
- バイナリプロべナンス：特定のバイナリアーティファクトがどのようにビルドされたかを記述する来歴の証明
  - ソースや依存関係、ビルドコマンド、環境、バージョニング、プロべナンスの真正性などが、プロべナンスフィールドとして記載される
- それぞれのデプロイメント環境が意図するプロパティを明示することで、デプロイされようとしているアーティファクトのプロべナンスと照合し、デプロイを検証できる
- ビルドの密封性、再現可能性、検証可能性
  - 密封：ビルドへの入力は全て、ビルドプロセス外で指定される。ビルド入力の分析やポリシーの適用、チェリーピッキングが可能になる。
  - 再現可能：同じ入力に対して同じビルドコマンドを適用し、ビット単位で同一の出力を得る。検証可能性、密封性、ビルドキャッシングのメリットがある
  - 検証可能：アーティファクトのバイナリプロべナンスを信頼できる方法で判断できる
- ポリシーの変更や、緊急ボタンによるデプロイ、インシデント後のフォレンジックのために、デプロイメント後の検証も必要となる
